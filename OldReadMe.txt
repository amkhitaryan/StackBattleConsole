-Основная "недоработка" то, что у арчеров нет дальности атаки, если обратит на это внимание - можно сказать, что так задумано. Лучники по сути далеко стреляют, в чем проблема собственно.
-Логика боя такова. Сначало идет размен в ближнем бою(первая фаза), для стратегии 1х1, бьёт тело с позиции[0] по телу на позиции[0], для 3х3: [0] по [0], [1] по [1], [2] по [2]. Очередность такая, что первая армия всегда бьет первой, т.е. либо 1 тело либо вся шеренга дает удар, потом получает обратку.
-Special Abilities у армий идут после первой фазы, для стратегии 1х1: с [1] позиции, для 3х3: с [3] позиции, для стратегии WallxWall: с последней+1 позиции юнита, меньшей армии. То есть в режиме стенка на стенку, если драка идет 5x7, то 5 тел бьют 5 тел из другой армии и получают обратку, а [6] и[7] юниты делают special ability. Т.е. это всегда будет только одна из армий(кто выполняет SA в режиме Wall)
-Т.к. названия юнитов в консоли основаны на названиях типов, там будет видно не совсем лаконичное "ProxyMage" и все в таком духе, но это впринципе не мешает. 
-При запуске программы из облака гугл драйва на другом компе и просмотре DLL GulyayGorod, там была DLL, отличная от той, на которой все тестировалось(моя DLL из моего старого проекта), поэтому тут аккуратно, он может как-то ссылаться на твою старую DLL, особенно, если выйдет exception в методе DeepClone, который требует параметра [Serializable] для класса.

По паттернам вроде основные понятно где. Proxy у тебя связан с Mage'ом, поэтому вместо него как раз и ProxyMage, он логирует все его движения в файл на рабочем столе, из меню можно просмотреть этот файл.
Observer прикреплен к Cleric'y, при его смерти идет запись в файл на рабочем столе, его также можно глянуть через меню, идет пик и смена цвета - в этой строке и будет видна инфа, про смерть лекаря.

Паттерн стратегия - делает undo-redo, сделана через сохранение состояний с помощью серилизации(достаточно сложно делать независимые копии ссылочных типов, т.е. List<IUnit>) это как один из вариантов.

По поводу декоратора. Конкретный декоратор хранит ссылку на декорируемый объект, т.е. тот, который без обертки, обертывает его = у него статы теперь другие. Следующий декоратор уже берет этот обернутый объект и сохраняет на него ссылку, потом также обертывает и его. Получается изначальный объект уже с 2 обертками, и так до 4 максимум, это впринципе можно много раз обертывать, но тут логически есть лимит. При необходимости(DEBUFF) декорированный объект приводится к первоначальному виду, путем присваивание его первоначального состояния, используя эту самую ссылку, полученную ранее. Т.е. все как надо.
